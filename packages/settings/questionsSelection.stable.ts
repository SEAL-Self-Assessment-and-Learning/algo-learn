/**
 * This file contains a list of all questions available on the give instance of SEAL.
 * TODO: In future this file should be generated by a script.
 */
import type { QuestionCollection } from "@shared/api/QuestionRouter"
import { Between } from "@shared/question-generators/asymptotics/between"
import { LandauNotation } from "@shared/question-generators/asymptotics/landau"
import { AsymptoticsPreciseLanguage } from "@shared/question-generators/asymptotics/preciseLanguage"
import { SortTerms } from "@shared/question-generators/asymptotics/sort"
import { SimplifySum } from "@shared/question-generators/asymptotics/sum"
import { DijkstraAlgorithm } from "@shared/question-generators/graph-algorithms/dijkstra"
import { DijkstraTableGenerator } from "@shared/question-generators/graph-algorithms/dijkstraTable"
import { TreeTraversal } from "@shared/question-generators/graph-algorithms/treeTraversal.ts"
import { HeapNeighbours } from "@shared/question-generators/heap/generatorNeighbours.ts"
import { HeapOperations } from "@shared/question-generators/heap/generatorOperations.ts"
import { HeapVerifying } from "@shared/question-generators/heap/generatorVerify.ts"
import { huffmanCoding } from "@shared/question-generators/huffman-coding/huffmanCoding"
import { CRT } from "@shared/question-generators/math/modularArithmetic/crt.ts"
import { ExtendedEuclideanAlgorithm } from "@shared/question-generators/math/modularArithmetic/eea.ts"
import { modFactor } from "@shared/question-generators/math/modularArithmetic/modFactorization.ts"
import { ModTricks } from "@shared/question-generators/math/modularArithmetic/modTricks.ts"
import { MinimizePropositionalLogic } from "@shared/question-generators/propositional-logic/minimize.ts"
import { NormalForms } from "@shared/question-generators/propositional-logic/normalForms"
import { ReadingSyntaxTrees } from "@shared/question-generators/propositional-logic/readingSyntaxTrees.ts"
import { Resolution } from "@shared/question-generators/propositional-logic/resolution.ts"
import { Satisfiability } from "@shared/question-generators/propositional-logic/satisfiability"
import { SemanticEquivalence } from "@shared/question-generators/propositional-logic/semanticEquivalence.ts"
import { TruthTableFillingGenerator } from "@shared/question-generators/propositional-logic/truthTableFillingGenerator.ts"
import { TruthTableReadingGenerator } from "@shared/question-generators/propositional-logic/truthTableReadingGenerator.ts"
import { queueQuestion } from "@shared/question-generators/Queue/QueueGenerator.ts"
import { RecursionFormula } from "@shared/question-generators/recursion/formula"
import { RecurrenceMaster } from "@shared/question-generators/recursion/recurrenceMaster"
import { stackQuestion } from "@shared/question-generators/Stack/StackGenerator.ts"
import { Loops } from "@shared/question-generators/time/loops"
import { QuickFindGenerator } from "@shared/question-generators/unionFind/quickFind/generatorQF.ts"

export const collection: QuestionCollection = [
  {
    slug: "propositional-logic",
    name: { de: "Aussagenlogik", en: "Propositional Logic" },
    topics: ["logic", "math"],
    description: {
      en: "Logic formulas and truth tables",
      de: "Logische Formeln und Wahrheitstabellen",
    },
    contents: [
      Satisfiability,
      NormalForms,
      SemanticEquivalence,
      TruthTableReadingGenerator,
      TruthTableFillingGenerator,
      ReadingSyntaxTrees,
      Resolution,
      MinimizePropositionalLogic,
    ],
  },
  {
    slug: "modular-arithmetic",
    name: { de: "Modulare Arithmetik", en: "Modular Arithmetic" },
    topics: ["math"],
    description: {
      en: "Numbers modulo n",
      de: "Rechnen modulo n",
    },
    contents: [ModTricks, CRT, modFactor, ExtendedEuclideanAlgorithm],
  },
  {
    slug: "asymptotics",
    name: { de: "Asymptotik", en: "Asymptotics" },
    topics: ["math"],
    description: {
      en: "Growth rates and limits",
      de: "Wachstumsraten und Grenzen",
    },
    contents: [AsymptoticsPreciseLanguage, SortTerms, LandauNotation, SimplifySum, Between],
    // image: new URL("../front-end/assets/images/skill-asymptotics.jpg", import.meta.url),
  },
  {
    slug: "recursion",
    name: { de: "Rekursion", en: "Recursion" },
    topics: ["recursion"],
    description: {
      en: "Functions calling themselves",
      de: "Funktionen, die sich selbst aufrufen",
    },
    contents: [RecursionFormula, RecurrenceMaster],
    // image: new URL("../front-end/assets/images/skill-recursion.jpg", import.meta.url),
  },
  {
    slug: "pseudocode",
    name: { de: "Pseudocode", en: "Pseudocode" },
    topics: ["pseudocode"],
    description: {
      en: "Algorithm notation practice",
      de: "Übung zur Algorithmusnotation",
    },
    contents: [Loops],
    // image: new URL("../front-end/assets/images/skill-time.jpg", import.meta.url),
  },
  {
    slug: "stack",
    name: { de: "Stacks und Queues", en: "Stacks and Queues" },
    topics: ["algorithms", "data-structures"],
    description: {
      en: "LIFO and FIFO structures",
      de: "LIFO- und FIFO-Strukturen",
    },
    contents: [stackQuestion, queueQuestion],
  },
  {
    slug: "heap",
    name: { de: "Heaps", en: "Heaps" },
    topics: ["algorithms", "data-structures"],
    description: {
      en: "Tree-based priority structures",
      de: "Baumbasierte Prioritätsstrukturen",
    },
    contents: [HeapOperations, HeapVerifying, HeapNeighbours],
  },
  {
    slug: "union-find",
    name: { de: "Union-Find", en: "Union-Find" },
    topics: ["algorithms", "data-structures"],
    description: {
      en: "Disjoint set operations",
      de: "Operationen auf disjunkten Mengen",
    },
    contents: [QuickFindGenerator],
  },
  {
    slug: "huffmancoding",
    name: { de: "Huffman-Codierung", en: "Huffman-Coding" },
    topics: ["algorithms"],
    description: {
      en: "Data compression algorithm",
      de: "Algorithmus zur Datenkompression",
    },
    contents: [huffmanCoding],
  },
  {
    slug: "graphs",
    name: { de: "Graphen", en: "Graphs" },
    topics: ["algorithms", "data-structures", "graph"],
    description: {
      en: "Nodes and edges",
      de: "Knoten und Kanten",
    },
    contents: [TreeTraversal],
  },
  {
    slug: "dijkstra",
    name: { de: "Dijkstra", en: "Dijkstra" },
    topics: ["algorithms", "graph"],
    description: {
      en: "Shortest path algorithm",
      de: "Kürzester-Pfad-Algorithmus",
    },
    contents: [DijkstraAlgorithm, DijkstraTableGenerator],
  },
]

export const oldPathToGenerator = {
  "asymptotics/precise-language": AsymptoticsPreciseLanguage,
  "asymptotics/sort": SortTerms,
  "asymptotics/landau": LandauNotation,
  "asymptotics/sum": SimplifySum,
  "asymptotics/between": Between,
  "recursion/formula": RecursionFormula,
  "recursion/master": RecurrenceMaster,
  "time/loops": Loops,
  "huffmancoding/huffmanCoding": huffmanCoding,
}
