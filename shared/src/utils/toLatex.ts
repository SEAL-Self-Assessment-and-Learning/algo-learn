import type {
  FreeTextQuestion,
  MultiFreeTextQuestion,
  MultipleChoiceQuestion,
  Question,
} from "../api/QuestionGenerator"
import { parseMarkdown, type ParseTree, type ParseTreeNode } from "./parseMarkdown"

/**
 * Function to render a given markdown-like string in LaTeX
 *
 * @param md The markdown-like string to render
 * @returns The LaTeX string
 */
export function markdownToLatex(md: string): string {
  return markdownTreeToLatex(parseMarkdown(md))
}

/**
 * Function to replace quotes in a string by latex-style quotes
 * @example
 *   replaceQuotes(`"Hello world!"`) // => "``Hello world!''"
 */
function replaceQuotes(text: string) {
  return text.replace(/"([^"]*?)"/g, "``$1''")
}

/**
 * Function to render a given markdown-like string in LaTeX
 *
 * @param tree tree of parsed Markdown
 * @returns The LaTeX string
 */
export function markdownTreeToLatex(tree: ParseTree | ParseTreeNode): string {
  if (typeof tree === "string") {
    return replaceQuotes(tree).replaceAll("#", "\\#")
  } else if (Array.isArray(tree)) {
    return tree.map(markdownTreeToLatex).join("")
  } else if (tree.kind === "$") {
    return `$${tree.child}$`
  } else if (tree.kind === "$$") {
    return `\\[${tree.child}\\]`
  } else if (tree.kind === "*") {
    return `\\emph{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "**") {
    return `\\textbf{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "`") {
    return `\\texttt{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "```") {
    return `\\begin{lstlisting}\n${markdownTreeToLatex(tree.child)}\n\\end{lstlisting}`
  } else if (tree.kind === ">") {
    return `\\begin{quote}\n${markdownTreeToLatex(tree.child)}\n\\end{quote}`
  } else if (tree.kind === "a") {
    return `\\href{${tree.url}}{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "table") {
    const { content, format } = tree.child
    const colSpec = format.alignment
      .map((align) => {
        if (align === "left") {
          return "l"
        } else if (align === "right") {
          return "r"
        } else if (align === "center") {
          return "c"
        } else {
          return "l"
        }
      })
      .join("")

    const [header, ...data] = content
    const headerRow = header.map((cell) => markdownTreeToLatex(cell)).join(" & ")
    const contentRows = data
      .map((row) => row.map((cell) => markdownTreeToLatex(cell)).join(" & "))
      .join(" \\\\\n")

    return `\n\n
    \\vspace{0.5\\baselineskip}\\begin{tabular}{${colSpec}}
  \\hline
  ${headerRow} \\\\
  \\hline
  ${contentRows} \\\\
  \\hline
\\end{tabular}`
  } else if (tree.kind === "input") {
    return `[[ ${tree.child} ]]`
  } else if (tree.kind === "list") {
    return `\\begin{itemize}
${tree.child.map((item) => "  \\item\n" + indent(markdownTreeToLatex(item.text).trim(), 4)).join("\n")}
\\end{itemize}`
  }

  // will never be reached:
  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
  throw new Error(`Unsupported markdown tree kind: ${tree.kind}`)
}

/**
 * Function to indent a given string
 * @param text The string to indent
 * @param spaces The number of spaces to indent by
 * @returns The indented string
 */
export function indent(text: string, spaces: number = 2): string {
  const padding = " ".repeat(spaces)
  return text
    .split("\n")
    .map((line) => (line.length > 0 ? padding + line : line))
    .join("\n")
}

/** Function to render the question in LaTeX */
export function questionToTex(question: Question): string {
  const t = question.type
  const template = `% Automatically generated by algo-learn on ${new Date().toISOString().split("T")[0]}
\\begin{exercise}[${markdownToLatex(question.name)}]% ${question.path} | ${t}
%INNER%
\\end{exercise}`
  if (t === "MultipleChoiceQuestion") {
    const q: MultipleChoiceQuestion = question
    const inner = indent(`${markdownToLatex(q.text ?? "")}
\\begin{itemize}
${q.answers.map((answer) => "  \\item\n" + indent(markdownToLatex(answer).trim(), 4)).join("\n")}
\\end{itemize}`)
    return template.replace("%INNER%", inner)
  } else if (t === "FreeTextQuestion") {
    const q: FreeTextQuestion = question
    const inner = markdownToLatex(q.text ?? "").trim() + "\n\n" + markdownToLatex(q.prompt ?? "").trim()
    return template.replace("%INNER%", indent(inner, 2))
  } else if (t === "MultiFreeTextQuestion") {
    const q: MultiFreeTextQuestion = question
    const inner = markdownToLatex(q.text ?? "").trim()
    return template.replace("%INNER%", indent(inner, 2))
  } else {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    throw new Error(`Unsupported question type: ${t}`)
  }
}
