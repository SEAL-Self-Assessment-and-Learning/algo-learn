import type {
  FreeTextQuestion,
  MultiFreeTextQuestion,
  MultipleChoiceQuestion,
  Question,
} from "../api/QuestionGenerator"
import { parseMarkdown, type ParseTree, type ParseTreeNode } from "./parseMarkdown"

/**
 * Function to render a given markdown-like string in LaTeX
 *
 * @param md The markdown-like string to render
 * @returns The LaTeX string
 */
export function markdownToLatex(md: string): string {
  return markdownTreeToLatex(parseMarkdown(md))
}

/**
 * Function to replace quotes in a string by latex-style quotes
 * @example
 *   replaceQuotes(`"Hello world!"`) // => "``Hello world!''"
 */
function replaceQuotes(text: string) {
  return text.replace(/"([^"]*?)"/g, "``$1''")
}

/**
 * Function to render a given markdown-like string in LaTeX
 *
 * @param tree tree of parsed Markdown
 * @returns The LaTeX string
 */
export function markdownTreeToLatex(tree: ParseTree | ParseTreeNode): string {
  if (typeof tree === "string") {
    return replaceQuotes(tree).replaceAll("#", "\\#")
  } else if (Array.isArray(tree)) {
    return tree.map(markdownTreeToLatex).join("")
  } else if (tree.kind === "$") {
    return `$${tree.child}$`
  } else if (tree.kind === "$$") {
    return `\\[${tree.child}\\]`
  } else if (tree.kind === "*") {
    return `\\emph{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "**") {
    return `\\textbf{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "`") {
    return `\\texttt{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "```") {
    return `\\begin{lstlisting}\n${markdownTreeToLatex(tree.child)}\n\\end{lstlisting}`
  } else if (tree.kind === ">") {
    return `\\begin{quote}\n${markdownTreeToLatex(tree.child)}\n\\end{quote}`
  } else if (tree.kind === "a") {
    return `\\href{${tree.url}}{${markdownTreeToLatex(tree.child)}}`
  } else if (tree.kind === "table") {
    const { content, format } = tree.child
    const colSpec = format.alignment
      .map((align, index) => {
        const vLine = format.hLines.includes(index) ? "|" : ""
        const spec = { left: "l", center: "c", right: "r" }[align]
        return `${spec}${vLine}`
      })
      .join("")

    const headerRow = format.header ? content[0] : undefined
    const bodyRows = format.header ? content.slice(1) : content
    const headerRowString = headerRow?.map(markdownTreeToLatex)?.join(" & ")
    const bodyRowsString = bodyRows
      .map((row, index) => {
        const hLine = format.hLines.includes(index + (headerRow ? 1 : 0)) ? "\\hline\n" : ""
        const rowString = row.map(markdownTreeToLatex).join(" & ")
        return `${rowString} \\\\\n${hLine}`
      })
      .join("")

    return `\n\n
    \\vspace{\\baselineskip}\\hspace{1cm}
\\begin{tabular}{${colSpec}}
${headerRowString ? headerRowString + " \\\\\n\\hline" : ""}
${bodyRowsString}
\\end{tabular}
\\vspace{\\baselineskip}\n\n`
  } else if (tree.kind === "input") {
    return `[[ ${tree.child.replaceAll("#", "\\#")} ]]`
  } else if (tree.kind === "list") {
    return `\\begin{itemize}
${tree.child.map((item) => "  \\item\n" + indent(markdownTreeToLatex(item.text).trim(), 4)).join("\n")}
\\end{itemize}`
  }

  // will never be reached:
  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
  throw new Error(`Unsupported markdown tree kind: ${tree.kind}`)
}

/**
 * Function to indent a given string
 * @param text The string to indent
 * @param spaces The number of spaces to indent by
 * @returns The indented string
 */
export function indent(text: string, spaces: number = 2): string {
  const padding = " ".repeat(spaces)
  return text
    .split("\n")
    .map((line) => (line.length > 0 ? padding + line : line))
    .join("\n")
}

/** Function to render the question in LaTeX */
export function questionToTex(question: Question): string {
  const t = question.type
  const template = `% Automatically generated by algo-learn on ${new Date().toISOString().split("T")[0]}
\\begin{exercise}[${markdownToLatex(question.name)}]% ${question.path} | ${t}
%INNER%
\\end{exercise}`
  if (t === "MultipleChoiceQuestion") {
    const q: MultipleChoiceQuestion = question
    const inner = indent(`${markdownToLatex(q.text ?? "")}
\\begin{itemize}
${q.answers.map((answer) => "  \\item\n" + indent(markdownToLatex(answer).trim(), 4)).join("\n")}
\\end{itemize}`)
    return template.replace("%INNER%", inner)
  } else if (t === "FreeTextQuestion") {
    const q: FreeTextQuestion = question
    const inner = markdownToLatex(q.text ?? "").trim() + "\n\n" + markdownToLatex(q.prompt ?? "").trim()
    return template.replace("%INNER%", indent(inner, 2))
  } else if (t === "MultiFreeTextQuestion") {
    const q: MultiFreeTextQuestion = question
    const inner = markdownToLatex(q.text ?? "").trim()
    return template.replace("%INNER%", indent(inner, 2))
  } else {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    throw new Error(`Unsupported question type: ${t}`)
  }
}
