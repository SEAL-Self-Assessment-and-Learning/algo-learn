import {
  createProductTerm,
  ProductTerm,
} from "@shared/question-generators/asymptotics/asymptoticsUtils.ts"
import { printStars } from "@shared/question-generators/recursion/formulaUtils.ts"
import {
  AdditionOption,
  BoundsOptions,
  createForLine,
  createIfBreak,
  createIfCondition,
  CubeOption,
  DivisionOption,
  MultiplicationOption,
  PowOption,
  SquareOption,
  StepOptions,
} from "@shared/question-generators/time/loopsUtils.ts"
import Random from "@shared/utils/random.ts"

/**
 * Sample the source code of a code for which the correct asymptotic complexity is searched
 * Basic construct function
 *
 * @param random
 * @returns - code, functionName, variable, solution
 *            - code: the source code
 *            - functionName: the name of the function
 *            - variable: the name of the variable
 *            - solution: the correct asymptotic complexity
 */
export function sampleLoopBigO(random: Random): {
  code: string
  functionName: string
  variable: string
  solution: ProductTerm
} {
  const functionName = random.choice("fghPp".split(""))
  const variable = random.choice("nmNMxyztk".split(""))
  const availableVarNames = "nmNMxyztk".split("").filter((c) => c !== variable)
  const { code, solution } = sampleBigO({ random, variable, availableVarNames })
  return { code, functionName, variable, solution }
}

export function sampleBigO({
  random,
  variable,
  availableVarNames = "nmNMxyztk".split(""),
}: {
  random: Random
  variable: string
  availableVarNames?: string[]
}) {
  // variable is the dependency of the runtime
  const innerVar1 = random.choice(availableVarNames)

  const { code, solution } = createFunctionTextandSolution({ variable, innerVar1, random })

  if (solution === undefined) {
    throw new Error("No solution found, we have to provide a valid solution")
  }

  return { code: code.join("").trim(), solution }
}

/**
 * This function returns the code and the solution of the problem
 * Question is generated by providing code snippets and just slight manipulation
 *
 * Not generating the explanation for now
 *
 * Example:
 * func f(M)
 *   for y from 3 to pow(2,M)
 *     print("**")
 * Solution: \Theta (2^M)
 *
 * @param variable
 * @param innerVar1
 * @param random
 */
function createFunctionTextandSolution({
  variable,
  innerVar1,
  random,
}: {
  variable: string
  innerVar1: string
  random: Random
}): { code: string[]; solution: ProductTerm; explanation: string } {
  const space2 = " ".repeat(2)
  const space4 = " ".repeat(4)
  const space6 = " ".repeat(6)

  const random2to5 = random.int(2, 5)

  const functionName = random.choice("fghp".split(""))
  const functionSpelled = random.choice(["function", "void", "func", "proc", "sub"])

  function forLine(endMani: BoundsOptions, stepMani: StepOptions) {
    return `${createForLine({
      end: variable,
      endManipulation: endMani,
      innerVar: innerVar1,
      indent: space2.length,
      start: random.int(1, 3).toString(),
      step: stepMani,
      timeOrStars: "time",
    })}`
  }

  const forLoopOptions = [
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${random.choice([
          `${forLine(manipulationSquare2(), "normal")}`,
          `${forLine(manipulationLinear(random), random.choice(["normal", { type: "add", value: random.int(2, 5) }]))}`,
        ])}`,
        `${space4}${ifStatementGreater(random, innerVar1)}`,
        `${createIfBreak({ indent: space6.length })}`,
      ],
      solution: createProductTerm({ polyexponent: 0 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationPoly(random), random.choice([{ type: "mult", value: random.int(2, 5) }]))}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ logexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine({ type: "log", value: random.int(2, 3) }, "normal")}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ logexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationLinear(random), random.choice(["normal", { type: "add", value: random.int(2, 5) }]))}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ polyexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationPowValue(random2to5), random.choice([{ type: "mult", value: random.int(2, 5) }]))}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ polyexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationPowSelf(), random.choice([{ type: "mult", value: random.int(2, 5) }]))}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ polyexponent: 1, logexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationLinear(random), { type: "mult", value: random.int(2, 5) })}`,
        `${space4}iterate over ${variable} elements`,
      ],
      solution: createProductTerm({ polyexponent: 2 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationSquare2(), "normal")}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ polyexponent: 2 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine("none", "normal")}`,
        `${space4}do MergeSort over ${random.choice([innerVar1, variable])} elements`,
      ],
      solution: createProductTerm({ polyexponent: 2, logexponent: 1 }),
      explanation: "",
    },
    {
      code: [
        `${functionSpelled} ${functionName}(${variable})\n`,
        `${forLine(manipulationPowValue(random2to5), "normal")}`,
        `${printStars(random.int(1, 3), space4.length)}`,
      ],
      solution: createProductTerm({ exponentialBase: random2to5 }),
      explanation: "",
    },
  ]

  return random.choice(forLoopOptions)
}

/**
 * Manipulation of BoundsOptions, which don't change the runtime of an algorithm
 * @param random
 */
function manipulationLinear(random: Random): BoundsOptions {
  /*
  Manipulation which don't change the runtime of an algorithm are:
  AdditionOption
  MultiplicationOption
  DivisionOption
   */
  const addOpt: AdditionOption = { type: "add", value: random.int(1, 3) * random.choice([1, -1]) }
  const multOpt: MultiplicationOption = { type: "mult", value: random.int(2, 4) }
  const divOpt: DivisionOption = { type: "div", value: random.int(2, 4) }

  return random.choice([addOpt, multOpt, divOpt, "none"])
}

function manipulationPoly(random: Random): BoundsOptions {
  const addOpt: AdditionOption = { type: "add", value: random.int(1, 3) * random.choice([1, -1]) }
  const multOpt: MultiplicationOption = { type: "mult", value: random.int(2, 4) }
  const divOpt: DivisionOption = { type: "div", value: random.int(2, 4) }
  const squareOpt: SquareOption = { type: "square" }
  const cubeOpt: CubeOption = { type: "cube" }

  return random.choice([addOpt, multOpt, divOpt, squareOpt, cubeOpt, "none"])
}

function manipulationSquare2(): SquareOption {
  return { type: "square" }
}

function manipulationPowValue(random2to5: number): PowOption {
  return { type: "pow", value: random2to5 }
}

function manipulationPowSelf(): PowOption {
  return { type: "pow", value: "self" }
}

function ifStatementGreater(random: Random, innerVar: string): string {
  return createIfCondition({
    innerVar1: innerVar,
    innerVar2: random.int(1000, 3000).toString(),
    condition: ">",
  })
}
