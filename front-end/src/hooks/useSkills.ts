import { useMemo } from "react"
import useLocalStorageState from "use-local-storage-state"
import { allParameterCombinations, Parameters } from "@shared/api/Parameters"
import { QuestionGenerator } from "@shared/api/QuestionGenerator"
import { deserializePath, serializeGeneratorCall } from "@shared/api/QuestionRouter"
import { min } from "@shared/utils/math"
import Random from "@shared/utils/random"
import { collection, oldpathToGenerator } from "../../../settings/questionsSelection"
import {
  SkillFeatures as BasicSkillFeatures,
  computeStrength,
  SkillFeaturesAndPredictions as SkillFeatures,
  SkillFeaturesAndPredictions,
} from "../utils/memoryModel"

/** Old format for log entries */
type LogEntryV0 = {
  question: string // example: "asymptotics/sum"
  variant: string // example: "pure"
  seed: string // example: "myseed"
  result: "pass" | "fail"
  timestamp: number // as returned by Date.now()
}

/** V1 format for log entries */
export type LogEntryV1 = {
  /**
   * The path is generated by serializeGeneratorCall(..) and is of the form
   * "asymptotics/sum/pure/myseed" (note that the language is not part of the
   * path here)
   */
  path: string

  /** Whether the question was answered correctly */
  result: "pass" | "fail"

  /** When the question was answered (as returned by Date.now()) */
  timestamp: number
}

/**
 * V2 format for log entries is the same,
 * but the path is now supposed to use the unique ID of the generator,
 * so it is of the form "sum/pure/myseed" instead of "asymptotics/sum/pure/myseed".
 */
export type LogEntryV2 = LogEntryV1

/**
 * Upgrade a log entry from V0 to V1
 *
 * @param e Log entry in V0 format
 * @returns Log entry in V1 format
 */
function upgradeV0ToV1(e: LogEntryV0): LogEntryV1 {
  return {
    path: e.question + "/" + e.variant + "/" + e.seed,
    result: e.result,
    timestamp: e.timestamp,
  }
}

/**
 * Upgrade a log entry from V0 to V1
 *
 * @param e Log entry in V1 format
 * @returns Log entry in V2 format
 */
function upgradeV1ToV2(e: LogEntryV1): LogEntryV2 | undefined {
  const { path, result, timestamp } = e
  const [skill, question, ...rest] = path.split("/")
  const tmp = skill + "/" + question
  if (tmp in oldpathToGenerator) {
    const id = oldpathToGenerator[tmp as keyof typeof oldpathToGenerator].id
    return { path: [id, ...rest].join("/"), result, timestamp }
  }
}

function byDescendingTimestamp(a: LogEntryV2, b: LogEntryV2) {
  return b.timestamp - a.timestamp
}

/** Upgrade the log if necessary and return the most recent version of the log. */
export function useLog() {
  const [logV0, setLogV0] = useLocalStorageState<Array<LogEntryV0>>("log", {
    defaultValue: [],
    storageSync: false,
  })
  const [logV1, setLogV1] = useLocalStorageState<Array<LogEntryV1>>("log-v1", {
    defaultValue: [],
    storageSync: false,
  })
  const [logV2, setLogV2] = useLocalStorageState<Array<LogEntryV2>>("log-v2", {
    defaultValue: [],
    storageSync: true,
  })

  if (logV0.length > 0) {
    console.log("The log in storage will now be upgraded from v0 to v1...")
    setLogV1(logV1.concat(logV0.map(upgradeV0ToV1)).sort(byDescendingTimestamp))
    setLogV0([])
  }

  if (logV1.length > 0) {
    console.log("The log in storage will now be upgraded from v1 to v2...")
    for (const x of logV1) {
      const y = upgradeV1ToV2(x)
      if (y !== undefined) logV2.push(y)
    }
    setLogV2(logV2.sort(byDescendingTimestamp))
    setLogV1([])
  }

  const log: Array<LogEntryV2> = logV2.sort(byDescendingTimestamp)
  for (let i = 0; i < log.length; i++) {
    if (logV2[i].timestamp !== log[i].timestamp) {
      console.log("Warning: The log in storage was not sorted... fixing it!")
      setLogV2(log)
      break
    }
  }
  for (let i = 0; i < log.length - 1; i++) {
    console.assert(
      log[i + 1].timestamp < log[i].timestamp,
      "Invariant failed: Each timestamp in the log must be unique!",
    )
  }
  return { log, setLog: setLogV2 }
}

/** Return the progress of the user */
export function useSkills() {
  const { log, setLog } = useLog()

  /* Compute the basic features of each skill (e.g., how often pass/fail?) */
  const basicFeatureMap = computeBasicFeatureMap({ log })

  /* Compute the strength of each skill (number between 0 and 1) */
  const featureMap = useMemo(() => computeFeatureMap({ basicFeatureMap }), [basicFeatureMap])

  const unlockedSkills = useMemo(() => computeUnlockedSkills({ featureMap }), [featureMap])

  function appendLogEntry(entry: LogEntryV2) {
    const newLog = log.slice()
    newLog.push(entry)
    setLog(newLog)
  }

  function clearLog() {
    setLog([])
  }

  return {
    featureMap,
    unlockedSkills,
    log,
    appendLogEntry,
    clearLog,
  }
}

/**
 * Computes the feature vector for all question variants
 *
 * @param props
 * @param props.log A user's full history
 * @returns The feature vector
 */
function computeBasicFeatureMap({ log }: { log: Array<LogEntryV2> }): {
  [path: string]: BasicSkillFeatures
} {
  const qualifyingPasses: { [path: string]: number } = {}
  const featureMap: { [path: string]: BasicSkillFeatures } = {}
  for (const generator of collection.flatMap((x) => x.contents)) {
    for (const parameters of allParameterCombinations(generator.expectedParameters)) {
      const path = serializeGeneratorCall({
        generator,
        parameters,
      })
      qualifyingPasses[path] = 0
      featureMap[path] = {
        mastered: false,
        numPassed: 0,
        numFailed: 0,
        lag: Infinity,
      }
    }
  }

  const now = Date.now()
  for (const e of log.slice().reverse()) {
    const generatorCall = deserializePath({
      path: e.path,
    })
    if (generatorCall === undefined) {
      // console.log(
      //   `Path ${e.path} was not found in allQuestionGeneratorRoutes. Skipping...`,
      // )
      continue
    }
    const { generator, parameters } = generatorCall
    const path = serializeGeneratorCall({
      generator,
      parameters,
    })
    featureMap[path].lag = min(featureMap[path].lag, (now - e.timestamp) / 3600 / 24 / 1000)

    /**
     * The mastery threshold is defined on each Question, or a default value of
     * 3 is used. We need at least 3 successive correct answers to "master" a
     * skill, which causes the successors of these skills to be unlocked.
     */
    const minQualifyingPasses = 3

    if (featureMap[path].mastered) {
      if (e.result === "pass") {
        featureMap[path].numPassed += 1
      } else {
        console.assert(e.result === "fail")
        featureMap[path].numFailed += 1
      }
    } else if (qualifyingPasses[path] < minQualifyingPasses) {
      if (e.result === "pass") {
        qualifyingPasses[path] += 1
      } else {
        qualifyingPasses[path] = 0
      }
    }
    if (qualifyingPasses[path] === minQualifyingPasses) {
      featureMap[path].mastered = true
      // featureMap[path].numPassed = Math.max(
      //   featureMap[path].numPassed,
      //   minQualifyingPasses
      // )
    }
  }
  return featureMap
}

/**
 * Computes the strength of each skill
 *
 * @param props
 * @param props.featureMap The feature vector
 * @returns The strength of each skill
 */
function computeFeatureMap({
  basicFeatureMap,
}: {
  basicFeatureMap: {
    [path: string]: BasicSkillFeatures
  }
}): {
  [path: string]: SkillFeatures
} {
  const featureMap: {
    [path: string]: SkillFeatures
  } = {}
  for (const [path, feature] of Object.entries(basicFeatureMap)) {
    featureMap[path] = computeStrength(feature)
  }
  return featureMap
}

/**
 * Given a strengthMap and a path, compute the average strength of all question
 * variants that exist within that path.
 *
 * @param props
 * @param props.strengthMap The strength of each skill
 * @param props.set The set of generator/parameter combinations to take the
 *   average over
 * @returns The average strength of all variants in the set
 */
export function averageStrength({
  strengthMap,
  set,
}: {
  strengthMap: {
    [path: string]: { p: number; h: number }
  }
  set: Array<{
    generator: QuestionGenerator
    parameters: Parameters
  }>
}): number {
  if (set.length === 0) return 0

  let avg = 0
  for (const { generator, parameters } of set) {
    avg += strengthMap[serializeGeneratorCall({ generator, parameters })].p
  }
  return avg / set.length
}

/**
 * Return a list of question variants sorted by strength from lowest to highest
 *
 * @param props
 * @param props.random The random number generator
 * @param props.featureMap The feature map
 * @param props.generatorCalls The list of question variants that should be
 *   sorted. Note that this list will be sorted in-place.
 * @returns The questionVariants list
 */
export function sortByStrength({
  random,
  featureMap,
  generatorCalls,
}: {
  random?: Random
  featureMap: {
    [path: string]: { p: number; h: number }
  }
  generatorCalls: Array<{
    generator: QuestionGenerator
    parameters: Parameters
  }>
}): Array<{
  generator: QuestionGenerator
  parameters: Parameters
}> {
  random?.shuffle(generatorCalls) // If random was provided, shuffle to break ties
  generatorCalls.sort(
    (a, b) => featureMap[serializeGeneratorCall(a)].p - featureMap[serializeGeneratorCall(b)].p,
  )
  return generatorCalls
}

/**
 * Returns all skills that are already unlocked. A skill unlocks only once all
 * dependencies are above thresholdStrength
 *
 * @param props
 * @param props.featureMap The feature vector
 * @param props.thresholdStrength The threshold for a skill to be considered
 *   unlocked
 * @returns The list of unlocked skills
 */
export function computeUnlockedSkills({
  featureMap,
  thresholdStrength = 0.75,
}: {
  featureMap: {
    [path: string]: SkillFeaturesAndPredictions
  }
  thresholdStrength?: number
}): string[] {
  // for now, we assume all question generators are independent and all variants strictly build on each other.
  const unlockedPaths = []
  for (const generator of collection.flatMap((x) => x.contents)) {
    for (const parameters of allParameterCombinations(generator.expectedParameters)) {
      const newPath = serializeGeneratorCall({ generator, parameters })
      unlockedPaths.push(newPath)
      if (featureMap[newPath].p < thresholdStrength || !featureMap[newPath].mastered) break
    }
  }
  return unlockedPaths
}
